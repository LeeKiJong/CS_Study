# Database
### [KEY]
#### [Candidate Key(후보키)]
- Tuple을 유일하게 식별하기 위해 사용하는 속성들의 부분 집합. (기본키로 사용할 수 있는 속성들)
- 아래 2가지 조건 만족
```
- 유일성 : Key로 하나의 Tuple을 유일하게 식별할 수 있음
- 최소성 : 꼭 필요한 속성으로만 구성
```
#### [Primary Key (기본키)]
- 후보키 중 선택한 Main Key
- 특징
```
- Null 값을 가질 수 없음
- 동일한 값이 중복될 수 없음
```
#### [Alternate Key (대체키)]
- 후보키 중 기본키를 제외한 나머지 키 = 보조키
#### [Super Key (슈퍼키)]
- 유일성은 만족하지만, 최소성은 만족하지 못하는 키
#### [Foreign Key (외래키)]
- 다른 릴레이션의 기본키를 그대로 참조하는 속성의 집합
---
### [Join]
- 두 개 이상의 테이블이나 데이터베이스를 연결하여 데이터를 검색하는 방법
#### [Join 종류]
- INNER JOIN
- LEFT OUTER JOIN
- RIGHT OUTER JOIN
- FULL OUTER JOIN
- CROSS JOIN
- SELF JOIN
#### [INNER JOIN]
![image](https://user-images.githubusercontent.com/52438368/176671097-591420e7-44ad-4dcb-bca2-785d89046273.png)
#### [LEFT OUTER JOIN]
![image](https://user-images.githubusercontent.com/52438368/176671280-755029e8-f646-495c-af0a-28a66fcf709d.png)

#### [RIGHT OUTER JOIN]
![image](https://user-images.githubusercontent.com/52438368/176671302-e1dad76c-9bd4-4edb-b16c-d7ce053fcc01.png)

#### [FULL OUTER JOIN]
![image](https://user-images.githubusercontent.com/52438368/176671320-bd9627f0-8723-4f04-acd7-b9a4cb42056b.png)

#### [CROSS JOIN]
![image](https://user-images.githubusercontent.com/52438368/176671360-2cc3a3ef-3c20-4f26-b35c-20eeca1ca008.png)

#### [SELF JOIN]
![image](https://user-images.githubusercontent.com/52438368/176671397-ef88eda1-3453-4be7-b6bf-8e01889d5ae4.png)
---
### [SQL Injection]
- 해커에 의해 조작된 SQL 쿼리문이 데이터베이스에 그대로 전달되어 비정상적 명령을 실행시키는 공격 기법
#### [인증 우회(공격 방법 1)]
- 보통 로그인을 할 때, 아이디와 비밀번호를 input 창에 입력하게 된다. 쉽게 이해하기 위해 가벼운 예를 들어보자. 아이디가 abc, 비밀번호가 만약 1234일 때 쿼리는 아래와 같은 방식으로 전송될 것이다.
```sql
SELECT * FROM USER WHERE ID = "abc" AND PASSWORD = "1234";
```
- SQL Injection으로 공격할 때, input 창에 비밀번호를 입력함과 동시에 다른 쿼리문을 함께 입력하는 것이다.
```sql
1234; DELETE * USER FROM ID = "1";
```
- 보안이 완벽하지 않은 경우, 이처럼 비밀번호가 아이디와 일치해서 True가 되고 뒤에 작성한 DELETE 문도 데이터베이스에 영향을 줄 수도 있게 되는 치명적인 상황이다.  
- 이 밖에도 기본 쿼리문의 WHERE 절에 OR문을 추가하여 '1' = '1'과 같은 true문을 작성하여 무조건 적용되도록 수정한 뒤 DB를 마음대로 조작할 수도 있다.

#### [데이터 노출(공격 방법 2)]
- 시스템에서 발생하는 에러 메시지를 이용해 공격하는 방법이다. 보통 에러는 개발자가 버그를 수정하는 면에서 도움을 받을 수 있는 존재다. 해커들은 이를 역이용해 악의적인 구문을 삽입하여 에러를 유발시킨다.  

- 즉 예를 들면, 해커는 GET 방식으로 동작하는 URL 쿼리 스트링을 추가하여 에러를 발생시킨다. 이에 해당하는 오류가 발생하면, 이를 통해 해당 웹앱의 데이터베이스 구조를 유추할 수 있고 해킹에 활용한다.

#### [input 값을 받을 때, 특수문자 여부 검사하기(방어 방법 1)]
- 로그인 전, 검증 로직을 추가하여 미리 설정한 특수문자들이 들어왔을 때 요청을 막아낸다. 

#### [SQL 서버 오류 발생 시, 해당하는 에러 메시지 감추기(방어 방법 2)]
- view를 활용하여 원본 데이터베이스 테이블에는 접근 권한을 높인다. 일반 사용자는 view로만 접근하여 에러를 볼 수 없도록 만든다.  

#### [preparestatement 사용하기(방어 방법 3)]
- preparestatement를 사용하면, 특수문자를 자동으로 escaping 해준다. (statement와는 다르게 쿼리문에서 전달인자 값을 ?로 받는 것) 이를 활용해 서버 측에서 필터링 과정을 통해서 공격을 방어한다.

---
### [SQL과 NOSQL의 차이]
- 보통 Spring에서 개발할 때는 MySQL을, Node.js에서는 MongoDB를 주로 사용했을 것이다.
- 하지만 그냥 단순히 프레임워크에 따라 결정하는 것이 아니다. 프로젝트를 진행하기에 앞서 적합한 데이터베이스를 택해야 한다. 차이점을 알아보자
#### [SQL(관계형 DB)]
- SQL을 사용하면 RDBMS에서 데이터를 저장, 수정, 삭제 및 검색 할 수 있음
- 관계형 데이터베이스에는 핵심적인 두 가지 특징이 있다.
```
데이터는 정해진 데이터 스키마에 따라 테이블에 저장된다.
데이터는 관계를 통해 여러 테이블에 분산된다.
```
- 데이터는 테이블에 레코드로 저장되는데, 각 테이블마다 명확하게 정의된 구조가 있다. 해당 구조는 필드의 이름과 데이터 유형으로 정의된다.

- 따라서 스키마를 준수하지 않은 레코드는 테이블에 추가할 수 없다. 즉, 스키마를 수정하지 않는 이상은 정해진 구조에 맞는 레코드만 추가가 가능한 것이 관계형 데이터베이스의 특징 중 하나다.

- 또한, 데이터의 중복을 피하기 위해 '관계'를 이용한다.
![image](https://user-images.githubusercontent.com/52438368/176675465-c398b1ec-7e3c-4060-a517-9763430a6012.png)

- 하나의 테이블에서 중복 없이 하나의 데이터만을 관리하기 때문에 다른 테이블에서 부정확한 데이터를 다룰 위험이 없어지는 장점이 있다.

#### [NoSQL(비관계형 DB)]
- 말그대로 관계형 DB의 반대다.
- 스키마도 없고, 관계도 없다!
- NoSQL에서는 레코드를 문서(documents)라고 부른다.
- 여기서 SQL과 핵심적인 차이가 있는데, SQL은 정해진 스키마를 따르지 않으면 데이터 추가가 불가능했다. 하지만 NoSQL에서는 다른 구조의 데이터를 같은 컬렉션에 추가가 가능하다.
- 문서(documents)는 Json과 비슷한 형태로 가지고 있다. 관계형 데이터베이스처럼 여러 테이블에 나누어담지 않고, 관련 데이터를 동일한 '컬렉션'에 넣는다.

- 따라서 위 사진에 SQL에서 진행한 Orders, Users, Products 테이블로 나눈 것을 NoSQL에서는 Orders에 한꺼번에 포함해서 저장하게 된다.

- 따라서 여러 테이블에 조인할 필요없이 이미 필요한 모든 것을 갖춘 문서를 작성하는 것이 NoSQL이다. (NoSQL에는 조인이라는 개념이 존재하지 않음)


- 그러면 조인하고 싶을 때 NoSQL은 어떻게 할까?
```
컬렉션을 통해 데이터를 복제하여 각 컬렉션 일부분에 속하는 데이터를 정확하게 산출하도록 한다.
```
- 하지만 이러면 데이터가 중복되어 서로 영향을 줄 위험이 있다. **따라서 조인을 잘 사용하지 않고 자주 변경되지 않는 데이터일 때 NoSQL을 쓰면 상당히 효율적이다.**

#### [확장 개녕]
-두 데이터베이스를 비교할 때 중요한 Scaling 개념도 존재한다.

-데이터베이스 서버의 확장성은 '수직적' 확장과 '수평적' 확장으로 나누어진다.

-수직적 확장 : 단순히 데이터베이스 서버의 성능을 향상시키는 것 (ex. CPU 업그레이드)
-수평적 확장 : 더 많은 서버가 추가되고 데이터베이스가 전체적으로 분산됨을 의미 (하나의 데이터베이스에서 작동하지만 여러 호스트에서 작동)

-데이터 저장 방식으로 인해 SQL 데이터베이스는 일반적으로 수직적 확장만 지원함

-수평적 확장은 NoSQL 데이터베이스에서만 가능

#### [그럼 둘 중에 뭘 선택?]
- 그럼 둘 중에 뭘 선택?
- 정답은 없다. 둘다 훌륭한 솔루션이고 어떤 데이터를 다루느냐에 따라 선택을 고려해야한다.
**SQL 장점**
```
명확하게 정의된 스키마, 데이터 무결성 보장
관계는 각 데이터를 중복없이 한번만 저장
```
**SQL 단점**
```
덜 유연함. 데이터 스키마를 사전에 계획하고 알려야 함. (나중에 수정하기 힘듦)
관계를 맺고 있어서 조인문이 많은 복잡한 쿼리가 만들어질 수 있음
대체로 수직적 확장만 가능함
```

**NoSQL 장점**
```
스키마가 없어서 유연함. 언제든지 저장된 데이터를 조정하고 새로운 필드 추가 가능
데이터는 애플리케이션이 필요로 하는 형식으로 저장됨. 데이터 읽어오는 속도 빨라짐
수직 및 수평 확장이 가능해서 애플리케이션이 발생시키는 모든 읽기/쓰기 요청 처리 가능
```

**NoSQL 단점**
```
유연성으로 인해 데이터 구조 결정을 미루게 될 수 있음
데이터 중복을 계속 업데이트 해야 함
데이터가 여러 컬렉션에 중복되어 있기 때문에 수정 시 모든 컬렉션에서 수행해야 함 (SQL에서는 중복 데이터가 없으므로 한번만 수행이 가능)
```

#### [SQL 데이터베이스 사용이 더 좋을 때]
```
관계를 맺고 있는 데이터가 자주 변경되는 애플리케이션의 경우
NoSQL에서는 여러 컬렉션을 모두 수정해야 하기 때문에 비효율적
변경될 여지가 없고, 명확한 스키마가 사용자와 데이터에게 중요한 경우
```
#### [NoSQL에서는 여러 컬렉션을 모두 수정해야 하기 때문에 비효율적]
```
정확한 데이터 구조를 알 수 없거나 변경/확장 될 수 있는 경우
읽기를 자주 하지만, 데이터 변경은 자주 없는 경우
데이터베이스를 수평으로 확장해야 하는 경우 (막대한 양의 데이터를 다뤄야 하는 경우)
```

하나의 제시 방법이지 완전한 정답이 정해져 있는 것은 아니다.  

SQL을 선택해서 복잡한 JOIN문을 만들지 않도록 설계하여 단점을 없앨 수도 있고  

NoSQL을 선택해서 중복 데이터를 줄이는 방법으로 설계해서 단점을 없앨 수도 있다.  
---
### [Anomaly]
- 정규화를 해야하는 이유는 잘못된 테이블 설계로 인해 Anomaly (이상 현상)가 나타나기 때문이다.
- 예) {Student ID, Course ID, Department, Course ID, Grade}
#### [삽입 이상(Insertion Anomaly)]
- 기본키가 {Student ID, Course ID} 인 경우 -> Course를 수강하지 않은 학생은 Course ID가 없는 현상이 발생함. 결국 Course ID를 Null로 할 수밖에 없는데, 기본키는 Null이 될 수 없으므로, Table에 추가될 수 없음.

- 굳이 삽입하기 위해서는 '미수강'과 같은 Course ID를 만들어야 함.

**불필요한 데이터를 추가해야지, 삽입할 수 있는 상황 = Insertion Anomaly**

#### [갱신 이상 (Update Anomaly)]
- 만약 어떤 학생의 전공 (Department) 이 "컴퓨터에서 음악"으로 바뀌는 경우.

- 모든 Department를 "음악"으로 바꾸어야 함. 그러나 일부를 깜빡하고 바꾸지 못하는 경우, 제대로 파악 못함.
- **일부만 변경하여, 데이터가 불일치 하는 모순의 문제 = Update Anomaly**
#### [삭제 이상 (Deletion Anomaly)]
- 만약 어떤 학생이 수강을 철회하는 경우, {Student ID, Course ID, Department, Course ID, Grade}의 정보 중

- Student ID, Department 와 같은 학생에 대한 정보도 함께 삭제됨.
- **튜플 삭제로 인해 꼭 필요한 데이터까지 함께 삭제되는 문제 = Deletion Anomaly**
### [Index]
#### [DB Index]
**1. 목적 : RDBMS에서 검색 속도를 높이기 위한 기술**
```
Table의 Column을 색인화 함 (따로 파일로 저장)
→ 해당 Table의 Record를 Full scan 하지 않음.
→ 색인화 된 (B+ Tree 구조로) Index 파일 검색으로 검색 속도 향상
```
**2. 과정 : Table을 생성하면, MYD, MYI, FRM 3개의 파일이 생성됨.**
```
FRM : 테이블 구조가 저장되어 있는 파일
MYD : 실제 데이터가 있는 파일
MYI : Index 정보가 들어가 있는 파일
```
- Index를 사용하지 않는 경우, MYI 파일은 비어져 있음. 그러나, 인덱싱하는 경우 MYI 파일이 생성됨.
- 이후에 사용자가 Select 쿼리로 Index를 사용하는 Column을 탐색 시, MYI 파일의 내용을 검색함.
**3. 단점**
- Index 생성시, .mdb 파일 크기가 증가함
- 한 페이지를 동시에 수정할 수 있는 병행성이 줄어듬.
- 인덱스 된 Field에서 Data를 업데이트하거나, Record를 추가 또는 삭제시 성능이 떨어짐.
- 데이터 변경 작업이 자주 일어나는 경우, Index를 재작성해야 하므로, 성능에 영향을 미침.
**상황 분석**
- 사용하면 좋은 경우
```
(1) Where 절에서 자주 사용되는 Column
(2) 외래키가 사용되는 Column
(3) Join에 자주 사용되는 Column
```
- Index 사용을 피해야 하는 경우
```
(1) Data 중복도가 높은 Column
(2) DML이 자주 일어나는 Column
```
**DML이 일어났을 때의 상황**
- INSERT
```
- 기존 Block에 여유가 없을 때, 새로운 Data가 입력됨
-> 새로운 Block을 할당 받은 후, Key를 옮기는 작업을 수행 (**많은 양의 Redo가 기록**되고, 유발)
-> Index split 작업 동안, 해당 Block의 Key 값에 대해서 DML이 블로킹 됨... 대기 이벤트 발생
```
- DELETE
```
[Table과 Index 상황 비교]
Table에서 data가 delete 되는 경우 : Data가 지워지고, 다른 Data가 그 공간을 사용 가능
Index에서 Data가 delete 되는 경우 : Data가 지워지지 않고, 사용 안 됨 표시만 해둠.
-> Table의 Data 수와 Index의 Data 수가 다를 수 있음.
```
- UPDATE
```
Table에서 update가 발생하면 -> Index는 Update 할 수 없음.
Index에서는 Delete가 발생한 후, 새로운 작업의 Insert 작업 / 2배의 작업이 소요되어, 힘듬
```
---
### [정규화(Normalization)]
- 가장 큰 목표는 테이블 간 중복된 데이터를 허용하지 않는 것이다.
- 중복된 데이터를 만들지 않으면, 무결성을 유지할 수 있고, DB 저장 용량 또한 효율적으로 관리할 수 있다.

[출처] https://gyoogle.dev/blog/computer-science/data-base/SQL%20Injection.html
